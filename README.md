# 202130129 전진영

# 4월 17일 (7주차)

## state 끌어올리기
* 이제 Board가 모든 state를 관리하므로 보모 Board 컴포넌트는 자식 Square 컴포넌트가 올바르
게 표시될 수 있도록 props를 전달합니다.

* Square를 클릭하면 자식 Square 컴포넌트가 부모 Board 컴포넌트에 Board의 state를 업데이트
하도록 요청합니다.

* Board의 state가 변경되면 Board 컴포넌트와 모든 자식 Square 컴포넌트가 자동으로 다시 렌더
링 됩니다.

* Board 컴포넌트에 속한 모든 Square의 state를 유지하면 나중에 승자를 결정할 수 있습니다.

• 사용자가 Board의 원쪽 위 사각형을 클린하여 X를 추가하면 어떤 일이 발생하는지 다시 한번 정
리해 보겠습니다.

I

1. 왼쪽 위 사각형을 클릭하면 button이 Square로부터 onClick _prop으로 받은 함수가 실행됩니
다.

* Square 컴포넌트는 Board에서 해당 함수를 onSquareClick props로 받았습니다.
* Board 컴포넌트는 JSX에서 해당 함수를 직접 정의했습니다.
* 이 함수는 0을 인수로 handleClick을 호출합니다.

2. handleClick은 인수 0을 사용하여 squares 배열의 첫 번째 엘리먼트를 null에서 X로 업데이트
합니다.

3. Board 컴포넌트의 squares state가 업데이트되어 Board와 그 모든 자식이 다시 렌더링 됩니
다.
→ 이에 따라 인덱스가 0인 Square 컴포넌트의 value prop이 null에서 X로 변경됩니다.

4. 최종적으로 사용자는 왼쪽 위 사각형을 클릭한 후 비어 있는 사각형이 X로 변경된 것을 확인할

* DOM <button> 엘리먼트의 onClick 어트리뷰트(속성)는 빌트인 컴포넌트이기 때문에 React에서
특별한 의미를 갖습니다.

* 사용자 정의 컴포넌트, 예를 들어 Square의 경우 이름은 사용자가 원하는 대로 지을 수 있습니
다.

* Square의 onSquareClick prop나 Board의 handleClick 함수에 어떠한 이름을 붙여도 코드는
동일하게 작동합니다.

* React에서는 주로 이벤트를 나타내는 prop에는 onSomething과 같은 이름을 사용하고, 이벤트를
처리하는 함수를 정의 할 때는 handleSomething과 같은 이름을 사용합니다.

### 불변성이 왜 중요할까요
* handleClick에서 기존 배열을 수정하는 대신 slice()를 호출하여 squares 배열의 사본을 생성
하는 방법에 주목하세요.

* 그 이유를 설명하기 위해 불변성과 불변성을 배우는 것이 중요한 이유에 대해 논의해 보겠습니다.

* 일반적으로 데이터를 변경하는 방법에는 두 가지가 있습니다.
1. 첫 번째 방법은 데이터의 값을 직접 변경하여 데이터를 변형 하는 것입니다.
2. 두 번째 방법은 원하는 변경 사항이 있는 새 복사본으로 데이터를 대체하는 것입니다.

* 최종 결과는 같지만, 원본 데이터를 직접 변형하지 않음으로써 몇 가지 이점을 얻을 수 있습니
다.

1. 불변성을 사용하면 복잡한 기능을 훨씬 쉽게 구현할 수 있습니다.

* 우리는 이 자습서의 뒷부분에서 게임의 진행 과정을 검토하고 과거 움직임으로 "돌아가기"를 할
수 있는 "시간 여행"기능을 구현할 예정입니다.

* 특정 작업을 실행 취소하고 다시 실행하는 기능은 이 게임에만 국한된 것이 아닌 앱의 일바적인
요구사항입니다.

* 직접적인 데이터 변경을 피하면 의전 버전의 데이터를 그대로 유지하여 나중에 재사용(또는 초기
화)할 수 있습니다.

# 4월 3일 (5주차)

## 화면 업데이트하기
- component가 특정 정보를 "기억"해 두었다가 표시하기를 원하는 경우가 있습니다.

- 예를 들어 버튼이 클릭된 횟수를 세고 싶을 수 있습니다.

- 이렇게 하려면 component에 state를 추가하면 됩니다.

- 먼저, React에서 useState를 import합니다.

- 이 코드를 보면 useState는 react 파일 안에 Named Exports로 선언되어 있는 여러 개의
component 중 하나는 것을 알 수 있습니다.

- 이제 component 내부에 state 변수를 선언할 수 있습니다.

- useState로부터 현재의 state를 저장할 수 있는 변수인 count와 이를 업데이트할 수 있
는 함수인 setCount를 얻을 수 있습니다.

- 이름은 자유롭게 지정할 수 있지만 [something, setSomething]으로 작성하는 것이 일반
적입니다.

- 즉, 변수 이름과 변수 이름 앞에 set을 붙인 업데이트 함수를 관용적으로 사용합니다.

## Hook 사용하기

use로 시작하는 함수를 Hook이라고 합니다.

- useState는 React에서 제공하는 내장 Hook입니다.

- 다른 내장 Hook은 API 참고서에서 찾아볼 수 있습니다.

- 또한 기존의 것들을 조합하여 자신만의 Hook을 작성할 수도 있습니다. 사용자 Hook.

- Hook은 다른 함수보다 더 제한적입니다.

- component 또는 다른 Hook의 상단에서만 Hook을 호출할 수 있습니다.

- 조건이나 반복문에서 usestate를 사용하고 싶다면 새 컴포넌트를 추출하여 그곳에 넣으
세요.


## Hooks의 사용 규칙(Rules of Hooks)
### 왜 이런 제한이 필요한가?
- React의 동작을 예측 가능하고, 안정성을 높이기 위해 필요한 규칙입니다.

1. rendering 순서를 보장하기 위해
조건문이나 반복문 안에서 Hooks를 사용하면 매 rendering마다 Hook의 호출 순서가 달
라질 수 있기 때문에 React가 상태를 제대로 추적할 수 없습니다.

2. 불필요한 사이드 이펙트 방지
component가 여러 번 rendering될 때마다 동일한 순서로 Hook이 실행되어야 React가
의도한 동작을 수행할 수 있습니다.

# 3월 20일 (3주차)

### node_modules
- git으로 관리하지 않기 때문에 디렉토리 이름이 흐릿하게 나와 있는 것을 확인할 수 있습니다. 

### public  
- 정적(static) 파일을 저장하는 디렉토리 입니다.   
- build 후 배포할 html, CSS, JavaScript 등이 보관되는 곳입니다.   
- 개발하면서 특별히 수정할 코드는 없습니다.

### public/index.html   
- React 앱이 마운트 되는 HTML 파일.   

### src/   
- React 프로젝트의 주요 코드가 위치하는 디렉토리 입니다.    
- 개발하면서 대부분의 작업이 이루어지는 곳입니다.

### src/App.js   
- 메인 component 로 필요한 sub component 를 모아서 관리합니다.   
- 출력을 위해서 index.js 로 전달됩니다.

### src/App.css   
- App.js에 적용되는 스타일을 정의하는 스타일 파일입니다.

### src/index.js   
- React 앱의 진입 점(entry point)으로 최종 렌더링이 되는 곳입니다.   
- ReactDOM.createRoot 를 사용하여 App.js를 렌더링합니다.

### src/index.css   
- 전역 스타일을 정의하는 스타일 파일입니다.

## 의존성 관리와 package.json
- package.json은 패키지의 의존성을 관리하는 파일입니다.
- 의존성(Dependency) 이란, 하나의 소프트웨어가 다른 소프트웨어(라이브러리, 패키지, 모듈 등) 에 의존하여 동작하는 관계를 말합니다.
- 즉, 어떤 프로젝트에 사용된 각종 패키지 등의 버전을 동일하게 유지하기 위한 것입니다.


# 3월 13일 (2주차)


## Node.js활용


- 웹서버
  * REST API, GraphQL API

- 실시간 애플리케이션
  * 실시간 알림, 채팅, 스트리밍


### Node.js의 장단점


## 장점

- JavaScript 풀스택 개발이 가능하여 생산성이 향상됨

- npm의 방대한 생태계를 활용 가능함

- 실시간 데이터 처리가 강력함

## 단점

- 콜백 지옥의 문제점

- 보안 취약의 문제점

