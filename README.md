# 202130129 전진영

# 5월 22일

## 새로운 React 앱 만들기
* Next.js (앱 라우터)
  * Next.js의 앱 라우터는 React의 아키텍처를 최대한 활용하여 풀 스택 React 앱을 활성화하는
React 프레임워크입니다.
  * Next.js는 Vercel에서 유지 관리합니다.
  * Next.js 앱을 빌드해서 Node.js와 서버리스 호스팅 혹은 자체 서버에 배포할 수 있습니다.
  * Next.js는 또한 서버가 필요 없는 정적 내보내기도 지원합니다.
  * Vercel은 추가적으로 옵트-인 윤료 클라우드 서비스도 지원합니다.
    * Opt-in이란 사용자가 옵션을 직접 선택할 수 있도록 하는 서비스 입니다.

## 설치하기
* React는 처음부터 점진적으로 적용할 수 있도록 설계되었으며 필요한 만큼 React를 사용할 수 있습니다. React를 맛보기로 접해보려거나, 간단한 HTML 페에지에 다양한 약간의 상호작용을 추가하거나, 복잡한 React 기반의 앱을 시작하고자 하는 경우, 이 섹션을 참고하세요

## React 시도하기
* 단순히 React를 사용해 보고 싶다면, 아무것도 설치할 필요 없습니다. 이 샌드박스를 통해 사용
해 보세요!

* Local에서 사용해 보고 싶다면 Node. js만 설치 하면 됩니다.

* 직접 편집하거나 오른쪽 상단의 "Fork(포크)" 버튼을 눌러 새 탭에서 열 수 있습니다.

* React 문서의 대부분 페이지에는 이와 같은 샌드박스가 있습니다.

* React 문서 외에도 CodeSandbox, StackBlitz, CodePen 등의 온라인 샌드박스에서 React를
지원합니다.

# 5월 15일

## 역 데이터 흐름 추가하기

* 지금까지 우리는 계층 구조 아래로 흐르는 props와 state의 함수로써 앱을 만들었습니다.

* 이제 사용자 입력에 따라state를 변경하려면 반대 반향의 데이터 흐름을 만들어야 합니다.

* 이를 위해서는 계층 구조의 하단에 있는 컴포넌트에서 FilterableProductTable의 state를 업데이트할 수 있어야 합니다.

* React는 데이터 흐름을 명시적으로 보이게 만들어 줍니다.

* 그러나 이는 전통적인 양방향 데이터 바인딩보다 조금 더 많은 타이핑이 필요합니다.

* 4단계의 예시에서 체크하거나 키보드를 타이핑할 경우 UI의 변화가 없고 입력을 무시하는 것을 확인할 수 있습니다.

* 이것은 의도적으로 <input value={filterText} /> 로 코드를 쓰면서 value라는 prop이 항상 FilterableProductTable의 filterText라는 state를 통해서 데이터를 받도록 정했기 때문입니다.

* filterText라는 state가 변경되는 것이 아니기 때문에 unput의 value는 변하지 않고 화면도 바뀌는 것이 없습니다.

* 우리는 사용자가 input을 변경할 때마다 사용자의 입력을 반영할 수 있도록 state를 업데이트하기를 원하빈다.

* state는 FilterableProductTable이 가지고 있고 state 변경을 위해서는 setTilterText와 setInStockOnly를 호출을 하면 됩니다.

* SearchBar가 FilteravleProductTable의 state를 업데이트랄 수 있도록 하려면, 이 함수들을 SearchBar로 전달해야 합니다.

## State가 어디에 있어야 할 지 정하기

* ProductTable의 props를 추가해 줍니다.

* ProductTable의 forEach문을 수정합니다.
  * 첫 번쨰 코드와 비교해 보면서 어디가 수정되었는지 정확하게 수정해 줘야 합니다.

* 아직 폼을 수정하는 작업이 작동하지 않습니다. 문서의 샌드박스에서 콘소 에러가 발생하고 그 이유를 설명하겠습니다.

* 완성된 코드를보면, ProductTable와 SearchBar가 filterText와 inStockOnly props를 table, input과 체크 박스를 랜더링하기 위해서 읽고 있습니다.

* 예를 들면, SearchBar input의 value를 아래와 같이 채우고 있습니다.



# 5월 08일

## UI를 컴포넌트 계층으로 쪼개기

* 먼저 모의 시안에 있는 모든 컴포넌트와 하위 컴포넌트 주변에 박스를 그리고, 그들에게 이름을
붙이면서 시작해 보세요.

디자이너와 함께 일한다면 그들이 이미 디자인 툴을 통하여 이 컴포넌트들에 이름을 정해 두었을
소도 있습니다. 한번 여쭤보세요!

* 어떤 배경을 가지고 있냐에 따라, 디자인 컴포넌트로 나누는 방법에 대한 관점이 달라질 수 있습니다.

* Programming : 새로운 함수나 객체를 만든느 방식과 같은 방법으로 해봅시다.
 - 이 중 단일책임 원칙을 반영하고자 한다면 컴포넌트는 한 번에 한 가지 일만 해야 합니다.
 - 만약 컴포넌트가 점점 커진다면 작은 하위 컴포턴트로 쪼개져야 하겠죠

 * CSS : 클래스 선택자를 무엇으로 만들지 생각해 봅시다.

 * JSON이 잘 구조화 되어 있다면, 종종 이것이 UI의 컴포넌트 구조가 자연스럽게 데이터 모델에
대응된다는 것을 발견할 수 있습니다.

* 이는 UI와 데이터 모델은 보통 갈은 정보 아키텍처, 즉 같은 구조를 가지기 때문입니다.

* UI를 컴포넌트로 분리하고, 각 컴포넌트가 데이터 모델에 매칭될 수 있도록 하세요.

# 4월 18일 (보강주차)

## Key 선택하기

* key는 React에서 특별하게 미리 지정된 프로퍼티입니다.

* 엘리먼트가 생성되면 React는 key 프로퍼티를 추출하여 반환되는 엘리먼트에 직접 key를 저장합
니다.

* key가 props로 전달되는 것처럼 보일 수 있지만, React는 자동으로 key를 사용해 업데이트할
컾포너트를 결정합니다.

* 보모가 지정한 key가 무엇인지 컴포넌트는 알 수 없습니다.

* 동적인 리스트를 만들 때마다 적절한 key를 할당하는 것을 강력하게 추천합니다.

* 적절한 key가 없는 경우 데이터의 재구성을 고려해 보세요.

* key가 지정되지 않은 경우, React는 경고를 표시하며 배열의 인덱스를 기본 key로 사용합니다.

* 배열 인덱스를 key로 사용하면 리스트 항목의 순서를 바꾸거나 항목을 추가/제거할 때 문제가 발
생합니다.

* 명시적으로 key={}나를 전달하면 경고는 사라지지만 배열의 인덱스를 사용할 때와 같은 문제가 발
생하므로 대부분은 초천하지 않습니다.

* 리스트가 다시 렌더링 되면 React는 각 리스트 항목의 key를 가져와서 이전 리스트의 항목에서
일치하는 key를 탐색합니다.

* 현재 리스트에서 의전에 존재하지 않았던 key가 있으면 React는 컴포넌트를 생성합니다.

* 만약 현재 리스트에 이전 리스트에 존재했던 key를 가지고 있지 않다면 React는 그 key를 가진
컴포너트를 제거합니다.

* 두 key가 일치한다면 해당 컴포넌트는 이동합니다.

* key는 갈 React가 각 컴포너트를 구별할 수 있도록 하여, 컴포넌트가 다시 렌더링 될 때 React
가 해당 컴포넌트의 state를 유지할 수 있게 합니다.

* 컴포넌트의 key가 변하면 컴포너트는 제거되고 새로운 state와 함께 다시 생성됩니다.

## map함수의 사용

* map의 기본 구문은 map(callbackFn)혹은 map(callbackFn, thisArg) 입니다.

* thisArg는 내부에서 this로 사용할 값을 지정하는데 화살표 함수에서는 생략됩니다.

* 따라서 예제에서는 callbackFn만 사용하고, 화살표 함수가 callback 함수를 대신합니다.

* squares, move는 화살표 함수의 매개변소 입니다.

1. history.map: history는 모든 플레이를 저장하는 배열입니다. 이 history에 map함 수를 적용
한다는 의미 입니다.

2. map함수는 history 각각의 요소 index를 순회하면서 squares 추출합니다.

3. 각 요소는 土가안의 실행문을 실행하면서 버튼을 생성합니다.

4. 이렇게 생성된 버튼은 moves 객체(배열)에 다시 저장됩니다.

5. move는 최종 rendering에 사용됩니다.

## 과거 움직임 보여주기

* 이제 틱택토 게임의 히스토리를 기록하기 때문에, 플레이어에게 과거 플레이 목록을 보여줄 수
있습니다.

* <button>과 같은 React 엘리먼트는 일반 JavaScript 객체이므로 애플리케이션에서 전달할 수
있습니다.

* React에서 여러 엘리먼트를 렌더링하려면 React 엘리먼트 배열을 사용할 수 있습니다.

* 이미 state에 이동 history 배열이 있기 때문에 이것을 React 엘리먼트 배열로 변환해야 합니
다.

* JavaScript에서 한 배열을 다른 배열로 변환하려면 배열 map 메서드를 사용하면 됩니다.

1. 플레이 history 배열을 화면의 버튼을 나타내는 React 엘리먼트로 변환합니다.

2. 과거의 플레이로 "점프"할 수 있는 버튼 목록을 표시하세요.

3. 이 것을 구현하기 위해서 Game 컴포넌트에서 history를 map을 이용해보겠습니다.

# 4월 17일 (7주차)

## state 끌어올리기
* 이제 Board가 모든 state를 관리하므로 보모 Board 컴포넌트는 자식 Square 컴포넌트가 올바르
게 표시될 수 있도록 props를 전달합니다.

* Square를 클릭하면 자식 Square 컴포넌트가 부모 Board 컴포넌트에 Board의 state를 업데이트
하도록 요청합니다.

* Board의 state가 변경되면 Board 컴포넌트와 모든 자식 Square 컴포넌트가 자동으로 다시 렌더
링 됩니다.

* Board 컴포넌트에 속한 모든 Square의 state를 유지하면 나중에 승자를 결정할 수 있습니다.

• 사용자가 Board의 원쪽 위 사각형을 클린하여 X를 추가하면 어떤 일이 발생하는지 다시 한번 정
리해 보겠습니다.

I

1. 왼쪽 위 사각형을 클릭하면 button이 Square로부터 onClick _prop으로 받은 함수가 실행됩니
다.

* Square 컴포넌트는 Board에서 해당 함수를 onSquareClick props로 받았습니다.
* Board 컴포넌트는 JSX에서 해당 함수를 직접 정의했습니다.
* 이 함수는 0을 인수로 handleClick을 호출합니다.

2. handleClick은 인수 0을 사용하여 squares 배열의 첫 번째 엘리먼트를 null에서 X로 업데이트
합니다.

3. Board 컴포넌트의 squares state가 업데이트되어 Board와 그 모든 자식이 다시 렌더링 됩니
다.
→ 이에 따라 인덱스가 0인 Square 컴포넌트의 value prop이 null에서 X로 변경됩니다.

4. 최종적으로 사용자는 왼쪽 위 사각형을 클릭한 후 비어 있는 사각형이 X로 변경된 것을 확인할

* DOM <button> 엘리먼트의 onClick 어트리뷰트(속성)는 빌트인 컴포넌트이기 때문에 React에서
특별한 의미를 갖습니다.

* 사용자 정의 컴포넌트, 예를 들어 Square의 경우 이름은 사용자가 원하는 대로 지을 수 있습니
다.

* Square의 onSquareClick prop나 Board의 handleClick 함수에 어떠한 이름을 붙여도 코드는
동일하게 작동합니다.

* React에서는 주로 이벤트를 나타내는 prop에는 onSomething과 같은 이름을 사용하고, 이벤트를
처리하는 함수를 정의 할 때는 handleSomething과 같은 이름을 사용합니다.

### 불변성이 왜 중요할까요
* handleClick에서 기존 배열을 수정하는 대신 slice()를 호출하여 squares 배열의 사본을 생성
하는 방법에 주목하세요.

* 그 이유를 설명하기 위해 불변성과 불변성을 배우는 것이 중요한 이유에 대해 논의해 보겠습니다.

* 일반적으로 데이터를 변경하는 방법에는 두 가지가 있습니다.
1. 첫 번째 방법은 데이터의 값을 직접 변경하여 데이터를 변형 하는 것입니다.
2. 두 번째 방법은 원하는 변경 사항이 있는 새 복사본으로 데이터를 대체하는 것입니다.

* 최종 결과는 같지만, 원본 데이터를 직접 변형하지 않음으로써 몇 가지 이점을 얻을 수 있습니
다.

1. 불변성을 사용하면 복잡한 기능을 훨씬 쉽게 구현할 수 있습니다.

* 우리는 이 자습서의 뒷부분에서 게임의 진행 과정을 검토하고 과거 움직임으로 "돌아가기"를 할
수 있는 "시간 여행"기능을 구현할 예정입니다.

* 특정 작업을 실행 취소하고 다시 실행하는 기능은 이 게임에만 국한된 것이 아닌 앱의 일바적인
요구사항입니다.

* 직접적인 데이터 변경을 피하면 의전 버전의 데이터를 그대로 유지하여 나중에 재사용(또는 초기
화)할 수 있습니다.

# 4월 3일 (5주차)

## 화면 업데이트하기
- component가 특정 정보를 "기억"해 두었다가 표시하기를 원하는 경우가 있습니다.

- 예를 들어 버튼이 클릭된 횟수를 세고 싶을 수 있습니다.

- 이렇게 하려면 component에 state를 추가하면 됩니다.

- 먼저, React에서 useState를 import합니다.

- 이 코드를 보면 useState는 react 파일 안에 Named Exports로 선언되어 있는 여러 개의
component 중 하나는 것을 알 수 있습니다.

- 이제 component 내부에 state 변수를 선언할 수 있습니다.

- useState로부터 현재의 state를 저장할 수 있는 변수인 count와 이를 업데이트할 수 있
는 함수인 setCount를 얻을 수 있습니다.

- 이름은 자유롭게 지정할 수 있지만 [something, setSomething]으로 작성하는 것이 일반
적입니다.

- 즉, 변수 이름과 변수 이름 앞에 set을 붙인 업데이트 함수를 관용적으로 사용합니다.

## Hook 사용하기

use로 시작하는 함수를 Hook이라고 합니다.

- useState는 React에서 제공하는 내장 Hook입니다.

- 다른 내장 Hook은 API 참고서에서 찾아볼 수 있습니다.

- 또한 기존의 것들을 조합하여 자신만의 Hook을 작성할 수도 있습니다. 사용자 Hook.

- Hook은 다른 함수보다 더 제한적입니다.

- component 또는 다른 Hook의 상단에서만 Hook을 호출할 수 있습니다.

- 조건이나 반복문에서 usestate를 사용하고 싶다면 새 컴포넌트를 추출하여 그곳에 넣으
세요.


## Hooks의 사용 규칙(Rules of Hooks)
### 왜 이런 제한이 필요한가?
- React의 동작을 예측 가능하고, 안정성을 높이기 위해 필요한 규칙입니다.

1. rendering 순서를 보장하기 위해
조건문이나 반복문 안에서 Hooks를 사용하면 매 rendering마다 Hook의 호출 순서가 달
라질 수 있기 때문에 React가 상태를 제대로 추적할 수 없습니다.

2. 불필요한 사이드 이펙트 방지
component가 여러 번 rendering될 때마다 동일한 순서로 Hook이 실행되어야 React가
의도한 동작을 수행할 수 있습니다.

# 3월 20일 (3주차)

### node_modules
- git으로 관리하지 않기 때문에 디렉토리 이름이 흐릿하게 나와 있는 것을 확인할 수 있습니다. 

### public  
- 정적(static) 파일을 저장하는 디렉토리 입니다.   
- build 후 배포할 html, CSS, JavaScript 등이 보관되는 곳입니다.   
- 개발하면서 특별히 수정할 코드는 없습니다.

### public/index.html   
- React 앱이 마운트 되는 HTML 파일.   

### src/   
- React 프로젝트의 주요 코드가 위치하는 디렉토리 입니다.    
- 개발하면서 대부분의 작업이 이루어지는 곳입니다.

### src/App.js   
- 메인 component 로 필요한 sub component 를 모아서 관리합니다.   
- 출력을 위해서 index.js 로 전달됩니다.

### src/App.css   
- App.js에 적용되는 스타일을 정의하는 스타일 파일입니다.

### src/index.js   
- React 앱의 진입 점(entry point)으로 최종 렌더링이 되는 곳입니다.   
- ReactDOM.createRoot 를 사용하여 App.js를 렌더링합니다.

### src/index.css   
- 전역 스타일을 정의하는 스타일 파일입니다.

## 의존성 관리와 package.json
- package.json은 패키지의 의존성을 관리하는 파일입니다.
- 의존성(Dependency) 이란, 하나의 소프트웨어가 다른 소프트웨어(라이브러리, 패키지, 모듈 등) 에 의존하여 동작하는 관계를 말합니다.
- 즉, 어떤 프로젝트에 사용된 각종 패키지 등의 버전을 동일하게 유지하기 위한 것입니다.


# 3월 13일 (2주차)


## Node.js활용


- 웹서버
  * REST API, GraphQL API

- 실시간 애플리케이션
  * 실시간 알림, 채팅, 스트리밍


### Node.js의 장단점


## 장점

- JavaScript 풀스택 개발이 가능하여 생산성이 향상됨

- npm의 방대한 생태계를 활용 가능함

- 실시간 데이터 처리가 강력함

## 단점

- 콜백 지옥의 문제점

- 보안 취약의 문제점

